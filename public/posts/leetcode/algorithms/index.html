<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Mick&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Sweep Line Meet In the Middle Find minimum diffs Calculate the sum, get the target, iterator num_cnt on one part of the half Partition Array Into Two Arrays to Minimize Sum Difference Kadane&rsquo;s Algorithm Maximum Subarray, find the subarray with the largest sum, and return its sum Just like sliding window, but in this case, the sum of the subarray is calculated. So when current subarray&rsquo;s sum is negative, instead of moving the start pointer forward until invalid, the remaining window is always empty, so we should set the start pointer to current end pointer Applies to all kinds of subarray, counting the max subarray value(could be occurence) Maximum subarray problem">
<meta name="author" content="Mick">
<link rel="canonical" href="https://mickjagger19.github.io/posts/leetcode/algorithms/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.8dd6f57454653644cba6929524e195dff93a26fa61dce2b3b2629e50b8d12816.css" integrity="sha256-jdb1dFRlNkTLppKVJOGV3/k6Jvph3OKzsmKeULjRKBY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://mickjagger19.github.io/favicon.ico">
<link rel="apple-touch-icon" href="https://mickjagger19.github.io/apple-touch-icon.png">
<link rel="alternate" hreflang="en" href="https://mickjagger19.github.io/posts/leetcode/algorithms/">

<meta name="twitter:title" content="Mick&#39;s Blog" />
<meta name="twitter:description" content="Sweep Line Meet In the Middle Find minimum diffs Calculate the sum, get the target, iterator num_cnt on one part of the half Partition Array Into Two Arrays to Minimize Sum Difference Kadane&rsquo;s Algorithm Maximum Subarray, find the subarray with the largest sum, and return its sum Just like sliding window, but in this case, the sum of the subarray is calculated. So when current subarray&rsquo;s sum is negative, instead of moving the start pointer forward until invalid, the remaining window is always empty, so we should set the start pointer to current end pointer Applies to all kinds of subarray, counting the max subarray value(could be occurence) Maximum subarray problem" />
<meta property="og:title" content="Mick&#39;s Blog" />
<meta property="og:description" content="Sweep Line Meet In the Middle Find minimum diffs Calculate the sum, get the target, iterator num_cnt on one part of the half Partition Array Into Two Arrays to Minimize Sum Difference Kadane&rsquo;s Algorithm Maximum Subarray, find the subarray with the largest sum, and return its sum Just like sliding window, but in this case, the sum of the subarray is calculated. So when current subarray&rsquo;s sum is negative, instead of moving the start pointer forward until invalid, the remaining window is always empty, so we should set the start pointer to current end pointer Applies to all kinds of subarray, counting the max subarray value(could be occurence) Maximum subarray problem" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mickjagger19.github.io/posts/leetcode/algorithms/" />
<meta property="article:section" content="posts" />
  
  


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://mickjagger19.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "",
      "item": "https://mickjagger19.github.io/posts/leetcode/algorithms/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Mick's Blog",
  "name": "",
  "description": "Sweep Line Meet In the Middle Find minimum diffs Calculate the sum, get the target, iterator num_cnt on one part of the half Partition Array Into Two Arrays to Minimize Sum Difference Kadane\u0026rsquo;s Algorithm Maximum Subarray, find the subarray with the largest sum, and return its sum Just like sliding window, but in this case, the sum of the subarray is calculated. So when current subarray\u0026rsquo;s sum is negative, instead of moving the start pointer forward until invalid, the remaining window is always empty, so we should set the start pointer to current end pointer Applies to all kinds of subarray, counting the max subarray value(could be occurence) Maximum subarray problem",
  "keywords": [
    
  ],
  "wordCount" : "1233",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Mick"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mickjagger19.github.io/posts/leetcode/algorithms/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mick's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mickjagger19.github.io/favicon.ico"
    }
  }
}
</script>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

</head>

<body class=" dark type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'dark';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mickjagger19.github.io" accesskey="h" title="Mick&#39;s Blog (Alt + H)">Mick&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mickjagger19.github.io/archives/" title="Archive"
                >Archive
                </a>
            </li>
            <li>
                <a href="https://mickjagger19.github.io/search/" title="Search"
                >Search
                </a>
            </li>
            <li>
                <a href="https://mickjagger19.github.io/tags/" title="Tags"
                >Tags
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mickjagger19.github.io">Home</a>&nbsp;»&nbsp;<a href="https://mickjagger19.github.io/posts/">Posts</a></div><h1 class="post-title"></h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><circle cx="12" cy="12" r="9"></circle><polyline points="12 7 12 12 15 15"></polyline></svg>
  <span>6 min</span></span>

      
      
    </div>
  </header> <div class="toc side right">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#sweep-line" aria-label="Sweep Line">Sweep Line</a></li>
                <li>
                    <a href="#meet-in-the-middle" aria-label="Meet In the Middle">Meet In the Middle</a></li>
                <li>
                    <a href="#kadanes-algorithm" aria-label="Kadane&amp;rsquo;s Algorithm">Kadane&rsquo;s Algorithm</a></li>
                <li>
                    <a href="#sliding-window" aria-label="Sliding Window">Sliding Window</a></li>
                <li>
                    <a href="#merge-sorts" aria-label="Merge Sorts">Merge Sorts</a></li>
                <li>
                    <a href="#boyer-morre-majority-vote" aria-label="Boyer-Morre majority Vote">Boyer-Morre majority Vote</a></li>
                <li>
                    <a href="#kmp" aria-label="KMP">KMP</a></li>
                <li>
                    <a href="#rabin-karp" aria-label="Rabin-Karp">Rabin-Karp</a></li>
                <li>
                    <a href="#reservior-sampling" aria-label="Reservior Sampling">Reservior Sampling</a></li>
                <li>
                    <a href="#binomial-coefficients" aria-label="Binomial Coefficients">Binomial Coefficients</a></li>
                <li>
                    <a href="#permutation" aria-label="Permutation">Permutation</a></li>
                <li>
                    <a href="#lis" aria-label="LIS">LIS</a></li>
                <li>
                    <a href="#suffix-array" aria-label="Suffix Array">Suffix Array</a></li>
                <li>
                    <a href="#z-function" aria-label="Z-function">Z-function</a></li>
                <li>
                    <a href="#re-rooting" aria-label="Re Rooting">Re Rooting</a></li>
                <li>
                    <a href="#eulerian-path" aria-label="Eulerian Path">Eulerian Path</a></li>
                <li>
                    <a href="#hamilton-path" aria-label="Hamilton Path">Hamilton Path</a></li>
                <li>
                    <a href="#de-brujin" aria-label="De Brujin">De Brujin</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="sweep-line">Sweep Line<a hidden class="anchor" aria-hidden="true" href="#sweep-line">¶</a></h2>
<h2 id="meet-in-the-middle">Meet In the Middle<a hidden class="anchor" aria-hidden="true" href="#meet-in-the-middle">¶</a></h2>
<ul>
<li>
<ul>
<li>Find minimum diffs</li>
<li>Calculate the sum, get the target, iterator num_cnt on one part of the half</li>
<li><a href="https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/description/">Partition Array Into Two Arrays to Minimize Sum Difference</a></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
<h2 id="kadanes-algorithm">Kadane&rsquo;s Algorithm<a hidden class="anchor" aria-hidden="true" href="#kadanes-algorithm">¶</a></h2>
<ul>
<li>
<ul>
<li>Maximum Subarray, find the subarray with the largest sum, and return its sum</li>
<li>Just like sliding window, but in this case, the sum of the subarray is calculated. So when current subarray&rsquo;s sum is negative, instead of moving the start pointer forward until invalid, the remaining window is always empty, so we should set the start pointer to current end pointer</li>
<li>Applies to all kinds of subarray, counting the max subarray value(could be occurence)</li>
</ul>
</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem">Maximum subarray problem</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">max_subarray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Find the largest sum of any contiguous subarray.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">best_sum</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">current_sum</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">numbers</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_sum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">current_sum</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">best_sum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">best_sum</span><span class="p">,</span> <span class="n">current_sum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">best_sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="sliding-window">Sliding Window<a hidden class="anchor" aria-hidden="true" href="#sliding-window">¶</a></h2>
<p>To find range that meets requirement
Valid, when :</p>
<ol>
<li>after a valid window, the end pointer needs to move forward to accept new elements</li>
<li>when the end pointer moves forward, the start pointer has to move forward to make the window valid again.</li>
</ol>
<ul>
<li>
<ul>
<li>Find minimum diffs</li>
<li>Calculate the sum, get the target, iterator num_cnt on one part of the half</li>
<li><a href="https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/description/">Partition Array Into Two Arrays to Minimize Sum Difference</a></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">long</span> <span class="kt">long</span> <span class="nf">countSubarrays</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">sum</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="merge-sorts">Merge Sorts<a hidden class="anchor" aria-hidden="true" href="#merge-sorts">¶</a></h2>
<p>merge process naturally fetch every two items from two sorted sub-arrays, and <strong>each</strong> item get to combined each item from the right at least once.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// each i in 0~mid have at least one combination to mid~n - 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">		<span class="n">temp</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">temp</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="boyer-morre-majority-vote">Boyer-Morre majority Vote<a hidden class="anchor" aria-hidden="true" href="#boyer-morre-majority-vote">¶</a></h2>
<p>for elements appear at least n / k times, maintain k candidates:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">can</span><span class="p">,</span><span class="n">cnt</span><span class="p">]</span><span class="o">:</span> <span class="n">candidates</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="n">can</span> <span class="o">=</span> <span class="n">num</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// check if the candidate appears at leask k times
</span></span></span></code></pre></div><h2 id="kmp">KMP<a hidden class="anchor" aria-hidden="true" href="#kmp">¶</a></h2>
<p>Generate the table</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">	<span class="c1">// kmp: [the index of the matching string] = [the index in the pattern string]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">kmp</span><span class="p">(</span><span class="n">evil</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kmp</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">evil</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">evil</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">kmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="n">kmp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// recursive step back, to get the max matching len
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">--</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>use the table as a tool, to determine if a string contains a pattern</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="n">n_ep</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">!=</span> <span class="n">evil</span><span class="p">[</span><span class="n">n_ep</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">	     <span class="c1">// calculate the max matching len of the character
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="n">n_ep</span> <span class="o">=</span> <span class="n">kmp</span><span class="p">[</span><span class="n">n_ep</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	 <span class="p">}</span>
</span></span></code></pre></div><h2 id="rabin-karp">Rabin-Karp<a hidden class="anchor" aria-hidden="true" href="#rabin-karp">¶</a></h2>
<p>To check existence of  <strong>exactly equal</strong> substrings
Time Complexity: O(len)
Rolling-hash to encode the seen string pattern in the set, check each hash value with the set</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">*</span> <span class="mi">26</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>
<ul>
<li>Find the longest duplicate substring</li>
<li>Binary Search + Rabin-Karp will do</li>
<li><a href="https://leetcode.com/problems/longest-duplicate-substring/solutions/?orderBy=most_votes">Longest Duplicate Substring</a></li>
</ul>
</li>
</ul>
<h2 id="reservior-sampling">Reservior Sampling<a hidden class="anchor" aria-hidden="true" href="#reservior-sampling">¶</a></h2>
<p>chance of placing cur item into reservior is $reservior_cnt/item_index$</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">(</span><span class="o">*</span> <span class="n">S</span> <span class="n">has</span> <span class="n">items</span> <span class="n">to</span> <span class="n">sample</span><span class="p">,</span> <span class="n">R</span> <span class="n">will</span> <span class="n">contain</span> <span class="n">the</span> <span class="n">result</span> <span class="o">*</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ReservoirSample</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">k</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// fill the reservoir array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="nl">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">k</span>
</span></span><span class="line"><span class="cl">      <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// replace elements with gradually decreasing probability
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="nl">i</span> <span class="p">:</span><span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="n">to</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// (* randomInteger(a, b) generates a uniform integer from the inclusive range {a, ..., b} *)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nl">j</span> <span class="p">:</span><span class="o">=</span> <span class="n">randomInteger</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span>
</span></span><span class="line"><span class="cl">        <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">:=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span></code></pre></div><h2 id="binomial-coefficients">Binomial Coefficients<a hidden class="anchor" aria-hidden="true" href="#binomial-coefficients">¶</a></h2>
<p>Stars and Bars: placing m bars in n numbers = choosing n locations from m = number of partition array of n into m <strong>subarray</strong></p>
<p>Forming an array of size n, with m consecutive unique numbers = placing m bars as transition in n numbers</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">	<span class="c1">// pascal&#39;s triangle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="c1">// nCr (comb)  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	        <span class="n">comb</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="n">comb</span><span class="p">[</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">comb</span><span class="p">[</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></div><p><a href="https://leetcode.com/problems/count-the-number-of-ideal-arrays/solutions/2265366/sieve-of-eratosthenes-o-maxvalue/?orderBy=most_votes">Count the Number of Ideal Arrays</a></p>
<h2 id="permutation">Permutation<a hidden class="anchor" aria-hidden="true" href="#permutation">¶</a></h2>
<ul>
<li>
<ul>
<li>Permutation of index</li>
<li>Recusive with bitmask, finding the next ununsed index</li>
<li><a href="https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/solutions/1238641/bit-mask/?orderBy=most_votes">Minimum XOR SUM Of Two Arrays</a></li>
</ul>
</li>
</ul>
<p><code>std::next_permutation</code></p>
<h2 id="lis">LIS<a hidden class="anchor" aria-hidden="true" href="#lis">¶</a></h2>
<ol>
<li>
<p>dp1:</p>
<ul>
<li>
<p>状态：以 a[i] 结尾的 LIS</p>
</li>
<li>
<p>转移： dp[i] = arr[i] &gt; arr[j] ? arr[j + 1]</p>
</li>
<li>
<p>复杂度：O(N^2)</p>
</li>
</ul>
</li>
<li>
<p>dp2:</p>
<ul>
<li>
<p>状态：a[i] 之前的，长度为 i + 1，末尾元素最小的 的 LIS</p>
</li>
<li>
<p>转移：</p>
<ul>
<li>每次将 a[i] 插入序列即可</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>复杂度：O(NlogN)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>    <span class="c1">// 记录dp当前最后一位的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">dp</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">               <span class="c1">// 组成更长的子序列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="n">dp</span><span class="p">[</span><span class="o">++</span><span class="n">pos</span><span class="p">]</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">           <span class="k">else</span>
</span></span><span class="line"><span class="cl">               <span class="c1">// 当前值更小，替换子序列串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">dp</span><span class="p">[</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="n">dp</span><span class="o">+</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="n">dp</span><span class="p">]</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><h2 id="suffix-array">Suffix Array<a hidden class="anchor" aria-hidden="true" href="#suffix-array">¶</a></h2>
<p>Sort all suffix substrings by starting index
Usage:</p>
<ul>
<li>compare substrings</li>
<li></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Structure to store information of a suffix
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">suffix</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="o">*</span><span class="n">suff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// A comparison function used by sort() to compare two suffixes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">struct</span> <span class="nc">suffix</span> <span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">suffix</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">suff</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">suff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// This is the main function that takes a string &#39;txt&#39; of size n as an
</span></span></span><span class="line"><span class="cl"><span class="c1">// argument, builds and return the suffix array for the given string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="nf">buildSuffixArray</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// A structure to store suffixes and their indexes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">struct</span> <span class="nc">suffix</span> <span class="n">suffixes</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Store suffixes and their indexes in an array of structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// The structure is needed to sort the suffixes alphabetically
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// and maintain their old indexes while sorting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">suffixes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">suffixes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">suff</span> <span class="o">=</span> <span class="p">(</span><span class="n">txt</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Sort the suffixes using the comparison function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// defined above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">sort</span><span class="p">(</span><span class="n">suffixes</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Store indexes of all sorted suffixes in the suffix array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="o">*</span><span class="n">suffixArr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">suffixArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffixes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Return the suffix array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="n">suffixArr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="z-function">Z-function<a hidden class="anchor" aria-hidden="true" href="#z-function">¶</a></h2>
<h2 id="re-rooting">Re Rooting<a hidden class="anchor" aria-hidden="true" href="#re-rooting">¶</a></h2>
<p>It says so on the post:</p>
<blockquote>
<ol>
<li>Arbitrary root the tree, lets take <code>node 0</code> for explanation.</li>
<li>Solve the given problem as if it was rooted at <code>node 0</code>.</li>
<li>Similarily solve the problem for all nodes</li>
</ol>
</blockquote>
<p>But I think it&rsquo;s still very vague.</p>
<p>DFS for once, use information from previous visit, to simulate differnt roots
*
*  Max Root Path Sum - Root
*  ans[i] = max(subtree sum, parent and its other subtree sum) - v[i]
* <a href="https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/solutions/3052596/re-rooting-o-n-explained/?orderBy=most_votes">Difference Between Maximum and Minimum Price Sum</a></p>
<ul>
<li>
<ul>
<li>Possible roots, given at least k of the parent-children query is correct( what the heck is this problem? )</li>
<li>Follow the steps, (1). assume 0 as the root, (2). calculate correct guess (3). DFS. While visiting a new child, correct guess changes atmost 1, updating corrent gusses and update final answer</li>
<li><a href="https://leetcode.com/problems/count-number-of-possible-root-nodes/solutions/3256065/re-rooting-o-n-explained/?orderBy=most_votes">Count Number of Possible Root Nodes</a></li>
</ul>
</li>
</ul>
<h2 id="eulerian-path">Eulerian Path<a hidden class="anchor" aria-hidden="true" href="#eulerian-path">¶</a></h2>
<ul>
<li>A graph has an Eulerian Path if and only if
<ol>
<li>we have <code>out[i] == in[i]</code> for each node <code>i</code>. Or</li>
<li>we have <code>out[i] == in[i]</code> for all nodes <code>i</code> except <strong>exactly two</strong> nodes <code>x</code> and <code>y</code>, with <code>out[x] = in[x] + 1</code>, <code>out[y] = in[y] - 1</code>, where x being the head, y being the tail</li>
</ol>
</li>
</ul>
<h2 id="hamilton-path">Hamilton Path<a hidden class="anchor" aria-hidden="true" href="#hamilton-path">¶</a></h2>
<h2 id="de-brujin">De Brujin<a hidden class="anchor" aria-hidden="true" href="#de-brujin">¶</a></h2>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="next" href="https://mickjagger19.github.io/posts/leetcode/basic-algorithms-you-must-memorize/">
    <span class="title">Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select: text;"><line x1="5" y1="12" x2="19" y2="12" style="user-select: text;"></line><polyline points="12 5 19 12 12 19" style="user-select: text;"></polyline></svg>
    </span>
    <br>
    <span></span>
  </a>
</nav>

  </footer>
    <div class="comments-separator"></div>
</article>
    </main>
    
<footer class="footer">
  <span>&copy; 2024 <a href="https://mickjagger19.github.io">Mick&#39;s Blog</a></span><span style="display: inline-block; margin-left: 1em;">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
  </span>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
    <path d="M12 6H0l6-6z" />
  </svg>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
    if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
      mybutton.style.visibility = "visible";
      mybutton.style.opacity = "1";
    } else {
      mybutton.style.visibility = "hidden";
      mybutton.style.opacity = "0";
    }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instant
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'copy';

    function copyingDone() {
      copybutton.innerText = 'copied!';
      setTimeout(() => {
        copybutton.innerText = 'copy';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

</body>

</html>
